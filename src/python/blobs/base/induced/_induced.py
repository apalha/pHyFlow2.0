"""General routines for computing induced velocities from different types of
vortex kernels.

Several different kernel implementations are implemented in one unified function.
"""
# Copyright (C) 2013 Artur Palha                                                                                                     
#                                                                                                                                   
# This file is part of pHyFlow.                                                                                                      
#                                                                                                                                   
# pHyFlow is free software: you can redistribute it and/or modify                                                                    
# it under the terms of the GNU Lesser General Public License as published by                                                       
# the Free Software Foundation, either version 3 of the License, or                                                                 
# (at your option) any later version.                                                                                               
#                                                                                                                                   
# pHyFlow is distributed in the hope that it will be useful,                                                                         
# but WITHOUT ANY WARRANTY; without even the implied warranty of                                                                    
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                                                                      
# GNU Lesser General Public License for more details.                                                                               
#                                                                                                                                   
# You should have received a copy of the GNU Lesser General Public License                                                          
# along with pHyFlow. If not, see <http://www.gnu.org/licenses/>.                                                                    
#                                                                                                                                   
# First added:  2013-05-22                                                                                                          
# Last changed: 2013-05-28
# -*- coding: utf-8 -*-

__all__ = ['velocity','vorticity','vorticity_blobs']

import numpy
from pHyFlow import options

from pHyFlow.cpp.blobs import kernels

def velocity(xBlob,yBlob,wBlob,sigma,k=2,kernel=1,\
             xEval=None,yEval=None,hardware=0,blocksize=128,method=0,\
             Ndirect=35,tol=1.0e-6,cutoff=None):
    """
        Compute the induced velocities generated by a distribution of nBlobs
        vortex blobs.
        
        Usage
        -----
            velocity(xBlob,yBlob,wBlob,sigma,k,kernel,
                     xEval,yEval,
                     hardware,blocksize)
            
        Parameters
        ----------
            xBlob :: the x coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                    
            yBlob :: the y coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            wBlob :: the circulations associated to each of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            sigma :: the core size of all the vortex blobs
            -----    (type: float (64bits); shape: single value)
                     
            k :: the core size multiplication constant of all the vortex blobs
                 typical values are 1,2,4 (default value is 2)
                 (type: float (64bits); shape: single value)
                 
            kernel :: the type of kernel of all the vortex blobs
                      available kernels are: 0 ('cutoff'), 1 ('gauss')
                      (default value is gauss kernel)
                      (type: int; shape: single value)
            
            xEval :: the x coordinates of the points where to evaluate the
                     induced velocities
                     (default value is None, which means xEval = xBlob)
                     (type: numpy.ndarray (float64); shape: (nEval,))
                     
            yEval :: the y coordinates of the points where to evaluate the
                     induced velocities
                     (default value is None, which means xEval = xBlob)
                     (type: numpy.ndarray (float64); shape: (nEval,))
                     
            hardware :: the hardware to use to compute the induced velocities
                        can be the 0 (for CPU) or 1 (for GPU)
                        (default value is CPU)
                        (type: int; shape: single value)
                                              
            blocksize :: the size of gpu memory block size
                         (default value 128)
                         (type: int; shape: single value)
           
            method :: the method used to compute the induced velocities can be
                      0 (for FMM) or 1 (for direct calculation)
                      (default value is direct calculation)
                      (type: int; shape: single value)
                      
            Ndirect :: the number of neighbor blobs where to perform direct calculation
                       (default value is 35)
                       (type: int; shape: single value)
            
            tol :: the tolerance (error) with which the induced velocities are computed
                   (default value is 1.0e-6)
                   (type: float64; shape: single value)
            
            cutoff :: the radius over which the velocity field is approximately 1/r^2
                      (default value is None, which corresponds to 5.0*xopt)
                      (type: float64; shape: single value)
                     
        Returns
        -------
            vx :: the x component of the induced velocities in each of the 
                  (xEval,yEval) points
                  (type: numpy.ndarray; shape: (nEval,))
                  
            vy :: the y component of the induced velocities in each of the 
                  (xEval,yEval) points
                  (type: numpy.ndarray; shape: (nEval,))
            
        First added:     2013-05-28

        Copyright (C) 2013 Artur Palha
                           pHyFlow
    """
    
    """    
        Reviews:    1. Help text added. (2013-05-28)
                    2. Kernel functions for Gauss (cpu and gpu) and
                       cutoff(cpu and gpu) added. (2013-06-06)
                    3. Option for method for calculating induced velocities
                       (FMM and direct) added. (2013-06-19)
                    4. Added FMM Gaussian method for computing induced
                       velocities, CPU and GPU versions (2013-10-11)
    """
    
    # compute optimized fullOption
    # the fullOtion is obtained as:
    #    100*method + 10*hardware + kernel
    # this means that if method = 2, hardware = 0 and kernel = 1 we get as
    # full option:
    #    100*2 + 10*0 + 1 = 201 this reduces the options
    fullOption = 100*method + 10*hardware + kernel
      
    # compute the induced velocities using the different options
    if fullOption == 100*options.DIRECT_METHOD + 10*options.CPU_HARDWARE + options.GAUSS_KERNEL: # direct calculation of Gaussian kernel on the CPU
        vx,vy = _velocity_direct_cpu_gauss(xBlob,yBlob,wBlob,sigma,k,xEval,yEval)
        
    elif fullOption == 100*options.DIRECT_METHOD + 10*options.CPU_HARDWARE + options.CUTOFF_KERNEL: # direct calculation of cutoff kernel on the CPU
        vx,vy = _velocity_direct_cpu_cutoff(xBlob,yBlob,wBlob,sigma,xEval,yEval)
        
    elif fullOption == 100*options.DIRECT_METHOD + 10*options.GPU_HARDWARE + options.GAUSS_KERNEL: # direct calculation of Gaussian kernel on the GPU
        vx,vy = _velocity_direct_gpu_gauss(xBlob,yBlob,wBlob,sigma,k,xEval,yEval,blocksize)
        
    elif fullOption == 100*options.DIRECT_METHOD + 10*options.GPU_HARDWARE + options.CUTOFF_KERNEL: # direct calculation of cutoff kernel on the GPU
        vx,vy = _velocity_direct_gpu_cutoff(xBlob,yBlob,wBlob,sigma,xEval,yEval,blocksize)
        
    elif fullOption == 100*options.FMM_METHOD + 10*options.CPU_HARDWARE + options.GAUSS_KERNEL: # FMM calculation of Gauss kernel on the CPU
        vx,vy = _velocity_fmm_cpu_gauss(xBlob,yBlob,wBlob,sigma,k,xEval,yEval,Ndirect,tol,cutoff)
        
    elif fullOption == 100*options.FMM_METHOD + 10*options.GPU_HARDWARE + options.GAUSS_KERNEL: # FMM calculation of Gauss kernel on the GPU
        vx,vy = _velocity_fmm_gpu_gauss(xBlob,yBlob,wBlob,sigma,k,xEval,yEval,Ndirect,tol,cutoff)
    
    elif fullOption == 100*options.FMM_METHOD + 10*options.CPU_HARDWARE + options.CUTOFF_KERNEL: # FMM calculation of cutoff kernel on the CPU
        raise Exception('FMM calculation of cutoff kernel on the CPU not yet available') 
    
    elif fullOption == 100*options.FMM_METHOD + 10*options.GPU_HARDWARE + options.CUTOFF_KERNEL: # FMM calculation of cutoff kernel on the GPU
        raise Exception('FMM calculation of cutoff kernel on the GPU not yet available')

    # return the computed velocities at the (xEval, yEval) points
    return vx,vy


def _velocity_fmm_cpu_gauss(xBlob,yBlob,wBlob,sigma,k,xEval,yEval,Ndirect,tol,cutoff):
    """
        Compute the induced velocities generated by a distribution of nBlobs
        vortex blobs with a Gaussian kernel on a CPU with fmm calculation.
        
        Usage
        -----
           vx,vy = _velocity_fmm_cpu_gauss(xBlob,yBlob,wBlob,sigma,k,
                                              xEval,yEval,Ndirect,tol,cutoff)
            
        Parameters
        ----------
            xBlob :: the x coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                    
            yBlob :: the y coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            wBlob :: the circulations associated to each of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            sigma :: the core size of all the vortex blobs
            -----    (type: float (64bits); shape: single value)
                     
            k :: the core size multiplication constant of all the vortex blobs
           ---   typical values are 1,2,4 
                 (type: float (64bits); shape: single value)
            
            xEval :: the x coordinates of the points where to evaluate the
            -----    induced velocities
                     (type: numpy.ndarray (float64); shape: (nEval,))
                     
            yEval :: the y coordinates of the points where to evaluate the
            -----    induced velocities
                     (type: numpy.ndarray (float64); shape: (nEval,))
                     
            Ndirect :: the number of neighbor blobs where to perform direct calculation
            -------    (type: int; shape: single value)
            
            tol :: the tolerance (error) with which the induced velocities are computed
            ---    (type: float64; shape: single value)
            
            cutoff :: the radius over which the velocity field is approximately 1/r^2
            ------    (type: float64; shape: single value)
                     
        Returns
        -------
            vx :: the x component of the induced velocities in each of the (xEval,yEval)
                  points
                  (type: numpy.ndarray; shape: (nEval,))
                  
            vy :: the y component of the induced velocities in each of the (xEval,yEval)
                  points
                  (type: numpy.ndarray; shape: (nEval,))
            
        First added:     2013-10-11

        Copyright (C) 2013 Artur Palha
                           pHyFlow
    """
    
    """    
        Reviews:    
    """
    
    #--------------------------------------------------------------------------
    # convert blob parameters into the parameters of the fmm solver
    alpha = 1.2564312086261696770 # is a constant internal to the fmm solver
    
    ksigmasqr = k*sigma*sigma
    xopt = numpy.sqrt(alpha*ksigmasqr)
    if cutoff==None: cutoff = 5.0*xopt
    #--------------------------------------------------------------------------
    
    # if no evaluation points are given, use the blobs coordinates
    if xEval==None:
        xEval = xBlob.copy()
        yEval = yBlob.copy()
    
    # compute the induced velocities
    vy_fmm,vx_fmm = kernels.gauss.fmm2d_cpu(xBlob,yBlob,wBlob,xEval,yEval,Ndirect,xopt,cutoff,tol)
    
    return -vx_fmm/(2.0*numpy.pi),-vy_fmm/(2.0*numpy.pi)
    

def _velocity_fmm_gpu_gauss(xBlob,yBlob,wBlob,sigma,k,xEval,yEval,Ndirect,tol,cutoff):
    """
        Compute the induced velocities generated by a distribution of nBlobs
        vortex blobs with a Gaussian kernel on a GPU with fmm calculation.
        
        Usage
        -----
           vx,vy = _velocity_fmm_gpu_gauss(xBlob,yBlob,wBlob,sigma,k,
                                              xEval,yEval,Ndirect,tol,cutoff)
            
        Parameters
        ----------
            xBlob :: the x coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                    
            yBlob :: the y coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            wBlob :: the circulations associated to each of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            sigma :: the core size of all the vortex blobs
            -----    (type: float (64bits); shape: single value)
                     
            k :: the core size multiplication constant of all the vortex blobs
           ---   typical values are 1,2,4 
                 (type: float (64bits); shape: single value)
            
            xEval :: the x coordinates of the points where to evaluate the
            -----    induced velocities
                     (type: numpy.ndarray (float64); shape: (nEval,))
                     
            yEval :: the y coordinates of the points where to evaluate the
            -----    induced velocities
                     (type: numpy.ndarray (float64); shape: (nEval,))
                     
            Ndirect :: the number of neighbor blobs where to perform direct calculation
            -------    (type: int; shape: single value)
            
            tol :: the tolerance (error) with which the induced velocities are computed
            ---    (type: float64; shape: single value)
            
            cutoff :: the radius over which the velocity field is approximately 1/r^2
            ------    (type: float64; shape: single value)
                     
        Returns
        -------
            vx :: the x component of the induced velocities in each of the (xEval,yEval)
                  points
                  (type: numpy.ndarray; shape: (nEval,))
                  
            vy :: the y component of the induced velocities in each of the (xEval,yEval)
                  points
                  (type: numpy.ndarray; shape: (nEval,))
            
        First added:     2013-10-11

        Copyright (C) 2013 Artur Palha
                           pHyFlow
    """
    
    """    
        Reviews:    
    """
    
    #--------------------------------------------------------------------------
    # convert blob parameters into the parameters of the fmm solver
    alpha = 1.2564312086261696770 # is a constant internal to the fmm solver
    
    ksigmasqr = k*sigma*sigma
    xopt = numpy.sqrt(alpha*ksigmasqr)
    if cutoff==None: cutoff = 5.0*xopt
    #--------------------------------------------------------------------------
    
    # if no evaluation points are given, use the blobs coordinates
    if xEval==None:
        xEval = xBlob.copy()
        yEval = yBlob.copy()
    
    # compute the induced velocities
    vy_fmm,vx_fmm = kernels.gauss.fmm2d_gpu(xBlob,yBlob,wBlob,xEval,yEval,Ndirect,xopt,cutoff,tol)
    
    return -vx_fmm/(2.0*numpy.pi),-vy_fmm/(2.0*numpy.pi)

    
def _velocity_direct_cpu_gauss(xBlob,yBlob,wBlob,sigma,k,xEval,yEval):
    """
        Compute the induced velocities generated by a distribution of nBlobs
        vortex blobs with a Gaussian kernel on a CPU with direct calculation.
        
        Usage
        -----
           vx,vy = _velocity_direct_cpu_gauss(xBlob,yBlob,wBlob,sigma,k,
                                              xEval,yEval)
            
        Parameters
        ----------
            xBlob :: the x coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                    
            yBlob :: the y coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            wBlob :: the circulations associated to each of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            sigma :: the core size of all the vortex blobs
            -----    (type: float (64bits); shape: single value)
                     
            k :: the core size multiplication constant of all the vortex blobs
           ---   typical values are 1,2,4 
                 (type: float (64bits); shape: single value)
            
            xEval :: the x coordinates of the points where to evaluate the
            -----    induced velocities
                     (type: numpy.ndarray (float64); shape: (nEval,))
                     
            yEval :: the y coordinates of the points where to evaluate the
            -----    induced velocities
                     (type: numpy.ndarray (float64); shape: (nEval,))
                     
        Returns
        -------
            vx :: the x component of the induced velocities in each of the (xEval,yEval)
                  points
                  (type: numpy.ndarray; shape: (nEval,))
                  
            vy :: the y component of the induced velocities in each of the (xEval,yEval)
                  points
                  (type: numpy.ndarray; shape: (nEval,))
            
        First added:     2013-06-19

        Copyright (C) 2013 Artur Palha
                           pHyFlow
    """
    
    """    
        Reviews:    
    """
    
    # if xEval is None use xBlob and yBlob for xEval and yEval
    if xEval == None:
        xEval = xBlob
        yEval = yBlob
    
    # use the external function to compute the induced velocities
    vx,vy = kernels.gauss.vv2parGauss_C_cpu(xBlob,yBlob,wBlob,xEval,yEval,k*sigma*sigma)
        
    # return the induced velocities
    return vx,vy
    
    

def _velocity_direct_gpu_gauss(xBlob,yBlob,wBlob,sigma,k,xEval,yEval,blocksize):
    """
        Compute the induced velocities generated by a distribution of nBlobs
        vortex blobs using a Gaussian kernel on a GPU with direct calculation.
        
        Usage
        -----
            vx,vy = _velocity_direct_gpu_gauss(xBlob,yBlob,wBlob,sigma,k,kernel,
                                               xEval,yEval,blocksize)
            
        Parameters
        ----------
            xBlob :: the x coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                    
            yBlob :: the y coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            wBlob :: the circulations associated to each of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            sigma :: the core size of all the vortex blobs
            -----    (type: float (64bits); shape: single value)
                     
            k :: the core size multiplication constant of all the vortex blobs
           ---   typical values are 1,2,4 
                 (type: float (64bits); shape: single value)
            
            xEval :: the x coordinates of the points where to evaluate the
            -----    induced velocities
                     (type: numpy.ndarray (float64); shape: (nEval,))
                     
            yEval :: the y coordinates of the points where to evaluate the
            -----    induced velocities
                     (type: numpy.ndarray (float64); shape: (nEval,))
            
            blocksize :: the size of gpu memory block size
            ---------    (type: int; shape: single value)
                     
        Returns
        -------
            vx :: the x component of the induced velocities in each of the (xEval,yEval)
                  points
                  (type: numpy.ndarray; shape: (nEval,))
                  
            vy :: the y component of the induced velocities in each of the (xEval,yEval)
                  points
                  (type: numpy.ndarray; shape: (nEval,))
            
        First added:     2013-06-19

        Copyright (C) 2013 Artur Palha
                           pHyFlow
    """
    
    """    
        Reviews:    1: Changed returned velocities from an array of (nEval,2)
                       array into two vectors of size nEval, one for vx and
                       another for vy. This change was done so that the
                       computation of the evolution of the blobs is faster.
                       Evolution in x only depends on vx and the same for y
                       in this way the computation of the evolution is faster
                       since there are less cache misses. (2013-06-21)
    """

    # Since the number of particles and the number of points where to evaluate
    # must be a multiple of the blocksize, make sure this is the case.
    # If not pad xBlob and yBlob with zeros
    
    # take the number of blobs and compute the closest
    # multiple of blocksize    
    nBlob = xBlob.shape[0]
    
    nBlobsNew = int(numpy.ceil(float(nBlob)/blocksize) * blocksize) # new number of blobs (multiple of blocksize)
    
    # generate the new blobs and eval coordinate vectors
    xBlobNew = numpy.zeros(nBlobsNew)
    xBlobNew[0:nBlob] = xBlob[:]
    
    yBlobNew = numpy.zeros(nBlobsNew)
    yBlobNew[0:nBlob] = yBlob[:]
    
    wBlobNew = numpy.zeros(nBlobsNew)
    wBlobNew[0:nBlob] = wBlob[:]
    
    # if xEval is None use xBlobNew and yBlobNew for xEvalNew and yEvalNew
    if xEval == None:
        # compute the number of eval points
        nEval = nBlob
        
        # it is already a multiple of block size so no correction is needed
        xEvalNew = xBlobNew.copy()
        yEvalNew = yBlobNew.copy()
        
    else:
        # compute the number of eval points and the new size
        nEval = xEval.shape[0]        
        nEvalNew = numpy.ceil(float(nEval)/blocksize) * blocksize # new number of eval points (multiple of blocksize)
        
         
        xEvalNew = numpy.zeros(nEvalNew)
        xEvalNew[0:nEval] = xEval[:]
    
        yEvalNew = numpy.zeros(nEvalNew)
        yEvalNew[0:nEval] = yEval[:]
    
    # use the external function to compute the induced velocities
    vx,vy = kernels.gauss.vv2parGauss_gpu(xBlobNew,yBlobNew,wBlobNew,xEvalNew,yEvalNew,k*sigma*sigma,blocksize)
                               
    # return the induced velocities
    return vx[0:nEval],vy[0:nEval]    
    
    
def _velocity_direct_cpu_cutoff(xBlob,yBlob,wBlob,sigma,xEval,yEval):
    """
        Compute the induced velocities generated by a distribution of nBlobs
        vortex blobs using a cutoff kernel on a CPU using direct calculation.
        
        Usage
        -----
            vx,vy = _velocity_direct_cpu_cutoff(xBlob,yBlob,wBlob,sigma,
                                                xEval,yEval)
            
        Parameters
        ----------
            xBlob :: the x coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                    
            yBlob :: the y coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            wBlob :: the circulations associated to each of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            sigma :: the core size of all the vortex blobs
            -----    (type: float (64bits); shape: single value)
            
            xEval :: the x coordinates of the points where to evaluate the
            -----    induced velocities
                     (type: numpy.ndarray (float64); shape: (nEval,))
                     
            yEval :: the y coordinates of the points where to evaluate the
            -----    induced velocities
                     (type: numpy.ndarray (float64); shape: (nEval,))
                     
        Returns
        -------
            vx :: the x component of the induced velocities in each of the (xEval,yEval)
                  points
                  (type: numpy.ndarray; shape: (nEval,))
                  
            vy :: the y component of the induced velocities in each of the (xEval,yEval)
                  points
                  (type: numpy.ndarray; shape: (nEval,))
            
        First added:     2013-06-20

        Copyright (C) 2013 Artur Palha
                           pHyFlow
    """
    
    """    
        Reviews:    1: Changed returned velocities from an array of (nEval,2)
                       array into two vectors of size nEval, one for vx and
                       another for vy. This change was done so that the
                       computation of the evolution of the blobs is faster.
                       Evolution in x only depends on vx and the same for y
                       in this way the computation of the evolution is faster
                       since there are less cache misses. (2013-06-21)
    """
    
    # if xEval is None use xBlob and yBlob for xEval and yEval
    if xEval == None:
        xEval = xBlob
        yEval = yBlob
    
    # use the external function to compute the induced velocities
    vx,vy = kernels.cutoff.vv2par_C_cpu(xBlob,yBlob,wBlob,xEval,yEval,sigma*sigma)
        
    # return the induced velocities
    return vx,vy
    
    

def _velocity_direct_gpu_cutoff(xBlob,yBlob,wBlob,sigma,xEval,yEval,blocksize):
    """
        Compute the induced velocities generated by a distribution of nBlobs
        vortex blobs with a cutoff kernel on a GPU with direct calculation.
        
        Usage
        -----
            vx,vy = _velocity_direct_gpu_cutoff(xBlob,yBlob,wBlob,sigma,xEval,
                                                yEval,blocksize)
            
        Parameters
        ----------
            xBlob :: the x coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                    
            yBlob :: the y coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            wBlob :: the circulations associated to each of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            sigma :: the core size of all the vortex blobs
            -----    (type: float (64bits); shape: single value)
          
            xEval :: the x coordinates of the points where to evaluate the
            -----    induced velocities
                     (type: numpy.ndarray (float64); shape: (nEval,))
                     
            yEval :: the y coordinates of the points where to evaluate the
            -----    induced velocities
                     (type: numpy.ndarray (float64); shape: (nEval,))
            
            blocksize :: the size of gpu memory block size
            ---------    (type: int; shape: single value)
                     
        Returns
        -------
            vx :: the x component of the induced velocities in each of the (xEval,yEval)
                  points
                  (type: numpy.ndarray; shape: (nEval,))
                  
            vy :: the y component of the induced velocities in each of the (xEval,yEval)
                  points
                  (type: numpy.ndarray; shape: (nEval,))
            
        First added:     2013-06-20

        Copyright (C) 2013 Artur Palha
                           pHyFlow
    """
    
    """    
        Reviews:    1: Changed returned velocities from an array of (nEval,2)
                       array into two vectors of size nEval, one for vx and
                       another for vy. This change was done so that the
                       computation of the evolution of the blobs is faster.
                       Evolution in x only depends on vx and the same for y
                       in this way the computation of the evolution is faster
                       since there are less cache misses. (2013-06-21)   
    """

    # Since the number of particles and the number of points where to evaluate
    # must be a multiple of the blocksize, make sure this is the case.
    # If not pad xBlob and yBlob with zeros
    
    # take the number of blobs and compute the closest
    # multiple of blocksize    
    nBlob = xBlob.shape[0]
    
    nBlobsNew = numpy.ceil(float(nBlob)/blocksize) * blocksize # new number of blobs (multiple of blocksize)
    
    # generate the new blobs and eval coordinate vectors
    xBlobNew = numpy.zeros(nBlobsNew)
    xBlobNew[0:nBlob] = xBlob[:]
    
    yBlobNew = numpy.zeros(nBlobsNew)
    yBlobNew[0:nBlob] = yBlob[:]
    
    wBlobNew = numpy.zeros(nBlobsNew)
    wBlobNew[0:nBlob] = wBlob[:]
    
    # if xEval is None use xBlobNew and yBlobNew for xEvalNew and yEvalNew
    if xEval == None:
        # compute the number of eval points
        nEval = nBlob
        
        # it is already a multiple of block size so no correction is needed
        xEvalNew = xBlobNew.copy()
        yEvalNew = yBlobNew.copy()
        
    else:
        # compute the number of eval points and the new size
        nEval = xEval.shape[0]        
        nEvalNew = numpy.ceil(float(nEval)/blocksize) * blocksize # new number of eval points (multiple of blocksize)
        
         
        xEvalNew = numpy.zeros(nEvalNew)
        xEvalNew[0:nEval] = xEval[:]
    
        yEvalNew = numpy.zeros(nEvalNew)
        yEvalNew[0:nEval] = yEval[:]
    
    # use the external function to compute the induced velocities
    vx,vy = kernels.cutoff.vv2par_gpu(xBlobNew,yBlobNew,wBlobNew,xEvalNew,yEvalNew,sigma*sigma,blocksize)
        
    # return the induced velocities
    return vx[0:nEval],vy[0:nEval]
    


def vorticity(xBlob,yBlob,wBlob,sigma,k=2,kernel=1,\
             xEval=None,yEval=None,hardware=0,blocksize=128,method=1):
    """
        Compute the induced vorticity generated by a distribution of nBlobs
        vortex blobs.
        
        Usage
        -----
            w = vorticity(xBlob,yBlob,wBlob,sigma,k=2,kernel=1,\
                          xEval=None,yEval=None,hardware=0,\
                          blocksize=128,method=1)
            
        Parameters
        ----------
            xBlob :: the x coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                    
            yBlob :: the y coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            wBlob :: the circulations associated to each of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            sigma :: the core size of all the vortex blobs
            -----    (type: float (64bits); shape: single value)
                     
            k :: the core size multiplication constant of all the vortex blobs
                 typical values are 1,2,4 (default value is 2)
                 (type: float (64bits); shape: single value)
                 
            kernel :: the type of kernel of all the vortex blobs
                      available kernels are: 0 ('cutoff'), 1 ('gauss')
                      (default value is gauss kernel)
                      (type: int; shape: single value)
            
            xEval :: the x coordinates of the points where to evaluate the
                     induced velocities
                     (default value is None, which means xEval = xBlob)
                     (type: numpy.ndarray (float64); shape: (nEval,))
                     
            yEval :: the y coordinates of the points where to evaluate the
                     induced velocities
                     (default value is None, which means xEval = xBlob)
                     (type: numpy.ndarray (float64); shape: (nEval,))
                     
            hardware :: the hardware to use to compute the induced velocities
                        can be the 0 (for CPU) or 1 (for GPU)
                        (default value is CPU)
                        (type: int; shape: single value)
            
            method :: the method used to compute the induced velocities can be
                      0 (for FMM) or 1 (for direct calculation)
                      (default value is direct calculation)
                      (type: int; shape: single value)
                                              
            blocksize :: the size of gpu memory block size
                         (default value 128)
                         (type: int; shape: single value)
                     
        Returns
        -------
            w :: the induced vorticity in each of the (xEval,yEval)
                 points
                 (type: numpy.ndarray; shape: (nEval,2))
            
        First added:     2013-06-26

        Copyright (C) 2013 Artur Palha
                           pHyFlow
    """
    
    """    
        Reviews:    
    """
    
    # compute optimized fullOption
    # the fullOtion is obtained as:
    #    100*method + 10*hardware + kernel
    # this means that if method = 2, hardware = 0 and kernel = 1 we get as
    # full option:
    #    100*2 + 10*0 + 1 = 201 this reduces the options
    fullOption = 100*method + 10*hardware + kernel
      
    # compute the induced vorticity using the different options
    if fullOption == 100*options.DIRECT_METHOD + 10*options.CPU_HARDWARE + options.GAUSS_KERNEL: # direct calculation of Gaussian kernel on the CPU
        w = _vorticity_direct_cpu_gauss(xBlob,yBlob,wBlob,sigma,k,xEval,yEval)
        
    elif fullOption == 100*options.DIRECT_METHOD + 10*options.CPU_HARDWARE + options.CUTOFF_KERNEL: # direct calculation of cutoff kernel on the CPU
        w = _vorticity_direct_cpu_cutoff(xBlob,yBlob,wBlob,sigma,xEval,yEval)
        
    elif fullOption == 100*options.DIRECT_METHOD + 10*options.GPU_HARDWARE + options.GAUSS_KERNEL: # direct calculation of Gaussian kernel on the GPU
        w = _vorticity_direct_gpu_gauss(xBlob,yBlob,wBlob,sigma,k,xEval,yEval,blocksize)
        
    elif fullOption == 100*options.DIRECT_METHOD + 10*options.GPU_HARDWARE + options.CUTOFF_KERNEL: # direct calculation of cutoff kernel on the GPU
        w = _vorticity_direct_gpu_cutoff(xBlob,yBlob,wBlob,sigma,xEval,yEval,blocksize)
        
    elif fullOption < 100*options.DIRECT_METHOD: # FMM calculation is not implemented yet
        raise Exception('FMM method not implemented yet')
        
    # return the computed vorticity at the (xEval, yEval) points
    return w
    
    
def _vorticity_direct_cpu_gauss(xBlob,yBlob,wBlob,sigma,k,xEval,yEval):
    """
        Compute the induced vorticity generated by a distribution of nBlobs
        vortex blobs with a Gaussian kernel on a CPU with direct calculation.
        
        Usage
        -----
           w = _vorticity_direct_cpu_gauss(xBlob,yBlob,wBlob,sigma,k,xEval,yEval)
            
        Parameters
        ----------
            xBlob :: the x coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                    
            yBlob :: the y coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            wBlob :: the circulations associated to each of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            sigma :: the core size of all the vortex blobs
            -----    (type: float (64bits); shape: single value)
                     
            k :: the core size multiplication constant of all the vortex blobs
           ---   typical values are 1,2,4 
                 (type: float (64bits); shape: single value)
            
            xEval :: the x coordinates of the points where to evaluate the
            -----    induced velocities
                     (type: numpy.ndarray (float64); shape: (nEval,))
                     
            yEval :: the y coordinates of the points where to evaluate the
            -----    induced velocities
                     (type: numpy.ndarray (float64); shape: (nEval,))
                     
        Returns
        -------
            w :: the induced vorticity in each of the (xEval,yEval) points
                 (type: numpy.ndarray; shape: (nEval,))
                  
            
        First added:     2013-06-26

        Copyright (C) 2013 Artur Palha
                           pHyFlow
    """
    
    """    
        Reviews:    
    """
    
    # if xEval is None use xBlob and yBlob for xEval and yEval
    if xEval == None:
        xEval = xBlob
        yEval = yBlob
    
    # use the external function to compute the induced velocities
    w = kernels.gauss.ww2parGauss_C_cpu(xBlob,yBlob,wBlob,xEval,yEval,k*sigma*sigma)
        
    # return the induced vorticity
    return w
    
    

def _vorticity_direct_gpu_gauss(xBlob,yBlob,wBlob,sigma,k,xEval,yEval,blocksize):
    """
        Compute the induced vorticity generated by a distribution of nBlobs
        vortex blobs using a Gaussian kernel on a GPU with direct calculation.
        
        Usage
        -----
            w = _vorticity_direct_gpu_gauss(xBlob,yBlob,wBlob,sigma,k,kernel,
                                            xEval,yEval,blocksize)
            
        Parameters
        ----------
            xBlob :: the x coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                    
            yBlob :: the y coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            wBlob :: the circulations associated to each of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            sigma :: the core size of all the vortex blobs
            -----    (type: float (64bits); shape: single value)
                     
            k :: the core size multiplication constant of all the vortex blobs
           ---   typical values are 1,2,4 
                 (type: float (64bits); shape: single value)
            
            xEval :: the x coordinates of the points where to evaluate the
            -----    induced velocities
                     (type: numpy.ndarray (float64); shape: (nEval,))
                     
            yEval :: the y coordinates of the points where to evaluate the
            -----    induced velocities
                     (type: numpy.ndarray (float64); shape: (nEval,))
            
            blocksize :: the size of gpu memory block size
            ---------    (type: int; shape: single value)
                     
        Returns
        -------
            w :: the x component of the induced vorticity in each of the 
                 (xEval,yEval) points
                 (type: numpy.ndarray; shape: (nEval,))
            
        First added:     2013-06-26

        Copyright (C) 2013 Artur Palha
                           pHyFlow
    """
    
    """    
        Reviews:
    """

    # Since the number of particles and the number of points where to evaluate
    # must be a multiple of the blocksize, make sure this is the case.
    # If not pad xBlob and yBlob with zeros
    
    # take the number of blobs and compute the closest
    # multiple of blocksize    
    nBlob = xBlob.shape[0]
    
    nBlobsNew = numpy.ceil(float(nBlob)/blocksize) * blocksize # new number of blobs (multiple of blocksize)
    
    # generate the new blobs and eval coordinate vectors
    xBlobNew = numpy.zeros(nBlobsNew)
    xBlobNew[0:nBlob] = xBlob[:]
    
    yBlobNew = numpy.zeros(nBlobsNew)
    yBlobNew[0:nBlob] = yBlob[:]
    
    wBlobNew = numpy.zeros(nBlobsNew)
    wBlobNew[0:nBlob] = wBlob[:]
    
    # if xEval is None use xBlobNew and yBlobNew for xEvalNew and yEvalNew
    if xEval == None:
        # it is already a multiple of block size so no correction is needed
        xEval = xBlob
        yEval = yBlob
        
    else:
        # compute the number of eval points and the new size
        nEval = xEval.shape[0]        
        nEvalNew = numpy.ceil(float(nEval)/blocksize) * blocksize # new number of eval points (multiple of blocksize)
        
         
        xEvalNew = numpy.zeros(nEvalNew)
        xEvalNew[0:nEval] = xEval[:]
    
        yEvalNew = numpy.zeros(nEvalNew)
        yEvalNew[0:nEval] = yEval[:]
    
    # use the external function to compute the induced vorticity
    w = kernels.gauss.ww2parGauss_gpu(xBlobNew,yBlobNew,wBlobNew,xEvalNew,yEvalNew,k*sigma*sigma,blocksize)
                               
    # return the induced velocities
    return w[0:nEval]   
    
    
def _vorticity_direct_cpu_cutoff(xBlob,yBlob,wBlob,sigma,xEval,yEval):
    """
        Compute the induced vorticity generated by a distribution of nBlobs
        vortex blobs using a cutoff kernel on a CPU using direct calculation.
        
        Usage
        -----
            w = _vorticity_direct_cpu_cutoff(xBlob,yBlob,wBlob,sigma,
                                             xEval,yEval)
            
        Parameters
        ----------
            xBlob :: the x coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                    
            yBlob :: the y coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            wBlob :: the circulations associated to each of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            sigma :: the core size of all the vortex blobs
            -----    (type: float (64bits); shape: single value)
            
            xEval :: the x coordinates of the points where to evaluate the
            -----    induced velocities
                     (type: numpy.ndarray (float64); shape: (nEval,))
                     
            yEval :: the y coordinates of the points where to evaluate the
            -----    induced velocities
                     (type: numpy.ndarray (float64); shape: (nEval,))
                     
        Returns
        -------
            w :: the x component of the induced vorticity in each of the 
                 (xEval,yEval) points
                 (type: numpy.ndarray; shape: (nEval,))
            
        First added:     2013-06-26

        Copyright (C) 2013 Artur Palha
                           pHyFlow
    """
    
    """    
        Reviews:    
    """
    
    # if xEval is None use xBlob and yBlob for xEval and yEval
    if xEval == None:
        xEval = xBlob
        yEval = yBlob
    
    # use the external function to compute the induced vorticity
    w = kernels.cutoff.ww2par_C_cpu(xBlob,yBlob,wBlob,xEval,yEval,sigma*sigma)
        
    # return the induced vorticity
    return w
    
    

def _vorticity_direct_gpu_cutoff(xBlob,yBlob,wBlob,sigma,xEval,yEval,blocksize):
    """
        Compute the induced vorticity generated by a distribution of nBlobs
        vortex blobs with a cutoff kernel on a GPU with direct calculation.
        
        Usage
        -----
            w = _vorticity_direct_gpu_cutoff(xBlob,yBlob,wBlob,sigma,xEval,
                                             yEval,blocksize)
            
        Parameters
        ----------
            xBlob :: the x coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                    
            yBlob :: the y coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            wBlob :: the circulations associated to each of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            sigma :: the core size of all the vortex blobs
            -----    (type: float (64bits); shape: single value)
          
            xEval :: the x coordinates of the points where to evaluate the
            -----    induced velocities
                     (type: numpy.ndarray (float64); shape: (nEval,))
                     
            yEval :: the y coordinates of the points where to evaluate the
            -----    induced velocities
                     (type: numpy.ndarray (float64); shape: (nEval,))
            
            blocksize :: the size of gpu memory block size
            ---------    (type: int; shape: single value)
                     
        Returns
        -------
            w :: the x component of the induced vorticity in each of the 
                 (xEval,yEval) points
                 (type: numpy.ndarray; shape: (nEval,))
            
        First added:     2013-06-26

        Copyright (C) 2013 Artur Palha
                           pHyFlow
    """
    
    """    
        Reviews:       
    """

    # Since the number of particles and the number of points where to evaluate
    # must be a multiple of the blocksize, make sure this is the case.
    # If not pad xBlob and yBlob with zeros
    
    # take the number of blobs and compute the closest
    # multiple of blocksize    
    nBlob = xBlob.shape[0]
    
    nBlobsNew = numpy.ceil(float(nBlob)/blocksize) * blocksize # new number of blobs (multiple of blocksize)
    
    # generate the new blobs and eval coordinate vectors
    xBlobNew = numpy.zeros(nBlobsNew)
    xBlobNew[0:nBlob] = xBlob[:]
    
    yBlobNew = numpy.zeros(nBlobsNew)
    yBlobNew[0:nBlob] = yBlob[:]
    
    wBlobNew = numpy.zeros(nBlobsNew)
    wBlobNew[0:nBlob] = wBlob[:]
    
    # if xEval is None use xBlobNew and yBlobNew for xEvalNew and yEvalNew
    if xEval == None:
        # it is already a multiple of block size so no correction is needed
        xEval = xBlob
        yEval = yBlob
        
    else:
        # compute the number of eval points and the new size
        nEval = xEval.shape[0]        
        nEvalNew = numpy.ceil(float(nEval)/blocksize) * blocksize # new number of eval points (multiple of blocksize)
        
         
        xEvalNew = numpy.zeros(nEvalNew)
        xEvalNew[0:nEval] = xEval[:]
    
        yEvalNew = numpy.zeros(nEvalNew)
        yEvalNew[0:nEval] = yEval[:]
    
    # use the external function to compute the induced vorticity
    w = kernels.cutoff.ww2par_gpu(xBlobNew,yBlobNew,wBlobNew,xEvalNew,yEvalNew,sigma*sigma,blocksize)
        
    # return the induced velocities
    return w[0:nEval]
    
    
    
def vorticity_blobs(xBlob,yBlob,wBlob,sigma,overlap,xBounds,yBounds):
    """
        Compute the vorticity generated by a distribution of nBlobs
        vortex blobs as given by their circulation:
            w_{i} = Gamma_{i}*deltaX*deltaY
        
        Usage
        -----
            xW,yW,w = vorticity_blobs(xBlob,yBlob,wBlob,sigma,overlap,
                                      xBounds,yBounds)
            
        Parameters
        ----------
            xBlob :: the x coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                    
            yBlob :: the y coordinates of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            wBlob :: the circulations associated to each of the vortex blobs
            -----    (type: numpy.ndarray (float64); shape: (nBlobs,))
                     
            sigma :: the core size of all the vortex blobs
            -----    (type: float (64bits); shape: single value)
                     
            overlap :: the overlap of the blobs
            -------    (default value is 0.5)
                       (type: float (64bits); shape: single value)
                       
            xBounds :: the x bounds of the box where to plot the induced field
            -------    (type: numpy.ndarray (float64); shape: (2,))
            
            yBounds :: the y bounds of the box where to plot the induced field
            -------    (type: numpy.ndarray (float64); shape: (2,))
            
                     
        Returns
        -------
                 
            xW :: the x coordinates of the points where vorticity is computed
                  points (row index corresponds to y coordinates and column
                 index corresponds to x coordinates)
                  (type: numpy.ndarray; shape: (nWx,nWy))
                 
            yW :: the y coordinates of the points where vorticity is computed
                  points (row index corresponds to y coordinates and column
                  index corresponds to x coordinates)
                  (type: numpy.ndarray; shape: (nWx,nWy))
           
            w :: the vorticity in each of the (xW,yW)
                 points (row index corresponds to y coordinates and column
                 index corresponds to x coordinates)
                 (type: numpy.ndarray; shape: (nWx,nWy))
                 
        First added:     2013-07-01

        Copyright (C) 2013 Artur Palha
                           pHyFlow
    """
    
    """    
        Reviews:    
    """
    
    """
        TODO:   1- Force remeshing to ensure the blobs are all centered at the
                   cells
    """
    
    # The main idea of this algorithm is to construct a grid of values of
    # vorticity given by indices (i,j), associated to a grid of cells where
    # the center is the location of the blobs. It is assumed that the blobs are
    # distributed over such a grid, if not the method gives wrong results.
    # We take the (xBounds[0],yBounds[0]) as initial point and get the indices of all the
    # blobs with respect to this. Then we neglect all the blobs whose indices
    # are negative.

    # take the first blob as reference
    x0 = xBlob[0]
    y0 = yBlob[0]

    # compute the spacing h between the blobs
    h = overlap * sigma
    
    # compute the relative indices of the blobs
    iIndices = numpy.array(numpy.round((xBlob - x0)/h),dtype=int)
    jIndices = numpy.array(numpy.round((yBlob - y0)/h),dtype=int)

    # compute indices of the bottom left and top right corners of the bounding box
    iBox = numpy.array([numpy.ceil((xBounds[0] - x0)/h), numpy.floor((xBounds[1] - x0)/h)],dtype=int)
    jBox = numpy.array([numpy.ceil((yBounds[0] - y0)/h), numpy.floor((yBounds[1] - y0)/h)],dtype=int)
    
    # flag the blobs to keep, the ones that are inside the bounding box
    blobsToKeep = (iIndices >= iBox[0]) * (iIndices <= iBox[1]) * (jIndices >= jBox[0]) * (jIndices <= jBox[1])

    # renormalize blob indices
    iIndices -= iBox[0]
    jIndices -= jBox[0]        
    
    # allocate memory space to store the output arrays with vorticity
    w = numpy.zeros((jBox[1]-jBox[0] + 1,iBox[1]-iBox[0] + 1))
    
    # store the flagged blobs
    w[jIndices[blobsToKeep],iIndices[blobsToKeep]] = wBlob[blobsToKeep]/(h*h)    
    
    # generate the coordinate arrays
    xW = (iBox[0]*h + xBlob[0]) + numpy.arange(iBox[1]-iBox[0] + 1)*h
    yW = (jBox[0]*h + yBlob[0]) + numpy.arange(jBox[1]-jBox[0] + 1)*h
    
    # generate the grid
    xW,yW = numpy.meshgrid(xW,yW)
    
    # return vorticity and location of the vorticity
    return xW,yW,w
    